// Generated by opcode_generator.rb from JavaScriptCore/b3/air/AirOpcode.opcodes -- do not edit!
#ifndef AirOpcodeGenerated_h
#define AirOpcodeGenerated_h
#include "AirInstInlines.h"
#include "wtf/PrintStream.h"
namespace WTF {
using namespace JSC::B3::Air;
void printInternal(PrintStream& out, Opcode opcode)
{
    switch (opcode) {
    case Opcode::Nop:
        out.print("Nop");
        return;
    case Opcode::Add32:
        out.print("Add32");
        return;
    case Opcode::Add8:
        out.print("Add8");
        return;
    case Opcode::Add16:
        out.print("Add16");
        return;
    case Opcode::Add64:
        out.print("Add64");
        return;
    case Opcode::AddDouble:
        out.print("AddDouble");
        return;
    case Opcode::AddFloat:
        out.print("AddFloat");
        return;
    case Opcode::Sub32:
        out.print("Sub32");
        return;
    case Opcode::Sub64:
        out.print("Sub64");
        return;
    case Opcode::SubDouble:
        out.print("SubDouble");
        return;
    case Opcode::SubFloat:
        out.print("SubFloat");
        return;
    case Opcode::Neg32:
        out.print("Neg32");
        return;
    case Opcode::Neg64:
        out.print("Neg64");
        return;
    case Opcode::NegateDouble:
        out.print("NegateDouble");
        return;
    case Opcode::NegateFloat:
        out.print("NegateFloat");
        return;
    case Opcode::Mul32:
        out.print("Mul32");
        return;
    case Opcode::Mul64:
        out.print("Mul64");
        return;
    case Opcode::MultiplyAdd32:
        out.print("MultiplyAdd32");
        return;
    case Opcode::MultiplyAdd64:
        out.print("MultiplyAdd64");
        return;
    case Opcode::MultiplySub32:
        out.print("MultiplySub32");
        return;
    case Opcode::MultiplySub64:
        out.print("MultiplySub64");
        return;
    case Opcode::MultiplyNeg32:
        out.print("MultiplyNeg32");
        return;
    case Opcode::MultiplyNeg64:
        out.print("MultiplyNeg64");
        return;
    case Opcode::Div32:
        out.print("Div32");
        return;
    case Opcode::UDiv32:
        out.print("UDiv32");
        return;
    case Opcode::Div64:
        out.print("Div64");
        return;
    case Opcode::UDiv64:
        out.print("UDiv64");
        return;
    case Opcode::MulDouble:
        out.print("MulDouble");
        return;
    case Opcode::MulFloat:
        out.print("MulFloat");
        return;
    case Opcode::DivDouble:
        out.print("DivDouble");
        return;
    case Opcode::DivFloat:
        out.print("DivFloat");
        return;
    case Opcode::X86ConvertToDoubleWord32:
        out.print("X86ConvertToDoubleWord32");
        return;
    case Opcode::X86ConvertToQuadWord64:
        out.print("X86ConvertToQuadWord64");
        return;
    case Opcode::X86Div32:
        out.print("X86Div32");
        return;
    case Opcode::X86UDiv32:
        out.print("X86UDiv32");
        return;
    case Opcode::X86Div64:
        out.print("X86Div64");
        return;
    case Opcode::X86UDiv64:
        out.print("X86UDiv64");
        return;
    case Opcode::Lea32:
        out.print("Lea32");
        return;
    case Opcode::Lea64:
        out.print("Lea64");
        return;
    case Opcode::And32:
        out.print("And32");
        return;
    case Opcode::And64:
        out.print("And64");
        return;
    case Opcode::AndDouble:
        out.print("AndDouble");
        return;
    case Opcode::AndFloat:
        out.print("AndFloat");
        return;
    case Opcode::OrDouble:
        out.print("OrDouble");
        return;
    case Opcode::OrFloat:
        out.print("OrFloat");
        return;
    case Opcode::XorDouble:
        out.print("XorDouble");
        return;
    case Opcode::XorFloat:
        out.print("XorFloat");
        return;
    case Opcode::Lshift32:
        out.print("Lshift32");
        return;
    case Opcode::Lshift64:
        out.print("Lshift64");
        return;
    case Opcode::Rshift32:
        out.print("Rshift32");
        return;
    case Opcode::Rshift64:
        out.print("Rshift64");
        return;
    case Opcode::Urshift32:
        out.print("Urshift32");
        return;
    case Opcode::Urshift64:
        out.print("Urshift64");
        return;
    case Opcode::RotateRight32:
        out.print("RotateRight32");
        return;
    case Opcode::RotateRight64:
        out.print("RotateRight64");
        return;
    case Opcode::RotateLeft32:
        out.print("RotateLeft32");
        return;
    case Opcode::RotateLeft64:
        out.print("RotateLeft64");
        return;
    case Opcode::Or32:
        out.print("Or32");
        return;
    case Opcode::Or64:
        out.print("Or64");
        return;
    case Opcode::Xor32:
        out.print("Xor32");
        return;
    case Opcode::Xor64:
        out.print("Xor64");
        return;
    case Opcode::Not32:
        out.print("Not32");
        return;
    case Opcode::Not64:
        out.print("Not64");
        return;
    case Opcode::AbsDouble:
        out.print("AbsDouble");
        return;
    case Opcode::AbsFloat:
        out.print("AbsFloat");
        return;
    case Opcode::CeilDouble:
        out.print("CeilDouble");
        return;
    case Opcode::CeilFloat:
        out.print("CeilFloat");
        return;
    case Opcode::FloorDouble:
        out.print("FloorDouble");
        return;
    case Opcode::FloorFloat:
        out.print("FloorFloat");
        return;
    case Opcode::SqrtDouble:
        out.print("SqrtDouble");
        return;
    case Opcode::SqrtFloat:
        out.print("SqrtFloat");
        return;
    case Opcode::ConvertInt32ToDouble:
        out.print("ConvertInt32ToDouble");
        return;
    case Opcode::ConvertInt64ToDouble:
        out.print("ConvertInt64ToDouble");
        return;
    case Opcode::ConvertInt32ToFloat:
        out.print("ConvertInt32ToFloat");
        return;
    case Opcode::ConvertInt64ToFloat:
        out.print("ConvertInt64ToFloat");
        return;
    case Opcode::CountLeadingZeros32:
        out.print("CountLeadingZeros32");
        return;
    case Opcode::CountLeadingZeros64:
        out.print("CountLeadingZeros64");
        return;
    case Opcode::ConvertDoubleToFloat:
        out.print("ConvertDoubleToFloat");
        return;
    case Opcode::ConvertFloatToDouble:
        out.print("ConvertFloatToDouble");
        return;
    case Opcode::Move:
        out.print("Move");
        return;
    case Opcode::Swap32:
        out.print("Swap32");
        return;
    case Opcode::Swap64:
        out.print("Swap64");
        return;
    case Opcode::Move32:
        out.print("Move32");
        return;
    case Opcode::StoreZero32:
        out.print("StoreZero32");
        return;
    case Opcode::StoreZero64:
        out.print("StoreZero64");
        return;
    case Opcode::SignExtend32ToPtr:
        out.print("SignExtend32ToPtr");
        return;
    case Opcode::ZeroExtend8To32:
        out.print("ZeroExtend8To32");
        return;
    case Opcode::SignExtend8To32:
        out.print("SignExtend8To32");
        return;
    case Opcode::ZeroExtend16To32:
        out.print("ZeroExtend16To32");
        return;
    case Opcode::SignExtend16To32:
        out.print("SignExtend16To32");
        return;
    case Opcode::MoveFloat:
        out.print("MoveFloat");
        return;
    case Opcode::MoveDouble:
        out.print("MoveDouble");
        return;
    case Opcode::MoveZeroToDouble:
        out.print("MoveZeroToDouble");
        return;
    case Opcode::Move64ToDouble:
        out.print("Move64ToDouble");
        return;
    case Opcode::Move32ToFloat:
        out.print("Move32ToFloat");
        return;
    case Opcode::MoveDoubleTo64:
        out.print("MoveDoubleTo64");
        return;
    case Opcode::MoveFloatTo32:
        out.print("MoveFloatTo32");
        return;
    case Opcode::Load8:
        out.print("Load8");
        return;
    case Opcode::LoadAcq8:
        out.print("LoadAcq8");
        return;
    case Opcode::Store8:
        out.print("Store8");
        return;
    case Opcode::StoreRel8:
        out.print("StoreRel8");
        return;
    case Opcode::Load8SignedExtendTo32:
        out.print("Load8SignedExtendTo32");
        return;
    case Opcode::LoadAcq8SignedExtendTo32:
        out.print("LoadAcq8SignedExtendTo32");
        return;
    case Opcode::Load16:
        out.print("Load16");
        return;
    case Opcode::LoadAcq16:
        out.print("LoadAcq16");
        return;
    case Opcode::Load16SignedExtendTo32:
        out.print("Load16SignedExtendTo32");
        return;
    case Opcode::LoadAcq16SignedExtendTo32:
        out.print("LoadAcq16SignedExtendTo32");
        return;
    case Opcode::Store16:
        out.print("Store16");
        return;
    case Opcode::StoreRel16:
        out.print("StoreRel16");
        return;
    case Opcode::LoadAcq32:
        out.print("LoadAcq32");
        return;
    case Opcode::StoreRel32:
        out.print("StoreRel32");
        return;
    case Opcode::LoadAcq64:
        out.print("LoadAcq64");
        return;
    case Opcode::StoreRel64:
        out.print("StoreRel64");
        return;
    case Opcode::Xchg8:
        out.print("Xchg8");
        return;
    case Opcode::Xchg16:
        out.print("Xchg16");
        return;
    case Opcode::Xchg32:
        out.print("Xchg32");
        return;
    case Opcode::Xchg64:
        out.print("Xchg64");
        return;
    case Opcode::AtomicStrongCAS8:
        out.print("AtomicStrongCAS8");
        return;
    case Opcode::AtomicStrongCAS16:
        out.print("AtomicStrongCAS16");
        return;
    case Opcode::AtomicStrongCAS32:
        out.print("AtomicStrongCAS32");
        return;
    case Opcode::AtomicStrongCAS64:
        out.print("AtomicStrongCAS64");
        return;
    case Opcode::BranchAtomicStrongCAS8:
        out.print("BranchAtomicStrongCAS8");
        return;
    case Opcode::BranchAtomicStrongCAS16:
        out.print("BranchAtomicStrongCAS16");
        return;
    case Opcode::BranchAtomicStrongCAS32:
        out.print("BranchAtomicStrongCAS32");
        return;
    case Opcode::BranchAtomicStrongCAS64:
        out.print("BranchAtomicStrongCAS64");
        return;
    case Opcode::AtomicAdd8:
        out.print("AtomicAdd8");
        return;
    case Opcode::AtomicAdd16:
        out.print("AtomicAdd16");
        return;
    case Opcode::AtomicAdd32:
        out.print("AtomicAdd32");
        return;
    case Opcode::AtomicAdd64:
        out.print("AtomicAdd64");
        return;
    case Opcode::AtomicSub8:
        out.print("AtomicSub8");
        return;
    case Opcode::AtomicSub16:
        out.print("AtomicSub16");
        return;
    case Opcode::AtomicSub32:
        out.print("AtomicSub32");
        return;
    case Opcode::AtomicSub64:
        out.print("AtomicSub64");
        return;
    case Opcode::AtomicAnd8:
        out.print("AtomicAnd8");
        return;
    case Opcode::AtomicAnd16:
        out.print("AtomicAnd16");
        return;
    case Opcode::AtomicAnd32:
        out.print("AtomicAnd32");
        return;
    case Opcode::AtomicAnd64:
        out.print("AtomicAnd64");
        return;
    case Opcode::AtomicOr8:
        out.print("AtomicOr8");
        return;
    case Opcode::AtomicOr16:
        out.print("AtomicOr16");
        return;
    case Opcode::AtomicOr32:
        out.print("AtomicOr32");
        return;
    case Opcode::AtomicOr64:
        out.print("AtomicOr64");
        return;
    case Opcode::AtomicXor8:
        out.print("AtomicXor8");
        return;
    case Opcode::AtomicXor16:
        out.print("AtomicXor16");
        return;
    case Opcode::AtomicXor32:
        out.print("AtomicXor32");
        return;
    case Opcode::AtomicXor64:
        out.print("AtomicXor64");
        return;
    case Opcode::AtomicNeg8:
        out.print("AtomicNeg8");
        return;
    case Opcode::AtomicNeg16:
        out.print("AtomicNeg16");
        return;
    case Opcode::AtomicNeg32:
        out.print("AtomicNeg32");
        return;
    case Opcode::AtomicNeg64:
        out.print("AtomicNeg64");
        return;
    case Opcode::AtomicNot8:
        out.print("AtomicNot8");
        return;
    case Opcode::AtomicNot16:
        out.print("AtomicNot16");
        return;
    case Opcode::AtomicNot32:
        out.print("AtomicNot32");
        return;
    case Opcode::AtomicNot64:
        out.print("AtomicNot64");
        return;
    case Opcode::AtomicXchgAdd8:
        out.print("AtomicXchgAdd8");
        return;
    case Opcode::AtomicXchgAdd16:
        out.print("AtomicXchgAdd16");
        return;
    case Opcode::AtomicXchgAdd32:
        out.print("AtomicXchgAdd32");
        return;
    case Opcode::AtomicXchgAdd64:
        out.print("AtomicXchgAdd64");
        return;
    case Opcode::AtomicXchg8:
        out.print("AtomicXchg8");
        return;
    case Opcode::AtomicXchg16:
        out.print("AtomicXchg16");
        return;
    case Opcode::AtomicXchg32:
        out.print("AtomicXchg32");
        return;
    case Opcode::AtomicXchg64:
        out.print("AtomicXchg64");
        return;
    case Opcode::LoadLink8:
        out.print("LoadLink8");
        return;
    case Opcode::LoadLinkAcq8:
        out.print("LoadLinkAcq8");
        return;
    case Opcode::StoreCond8:
        out.print("StoreCond8");
        return;
    case Opcode::StoreCondRel8:
        out.print("StoreCondRel8");
        return;
    case Opcode::LoadLink16:
        out.print("LoadLink16");
        return;
    case Opcode::LoadLinkAcq16:
        out.print("LoadLinkAcq16");
        return;
    case Opcode::StoreCond16:
        out.print("StoreCond16");
        return;
    case Opcode::StoreCondRel16:
        out.print("StoreCondRel16");
        return;
    case Opcode::LoadLink32:
        out.print("LoadLink32");
        return;
    case Opcode::LoadLinkAcq32:
        out.print("LoadLinkAcq32");
        return;
    case Opcode::StoreCond32:
        out.print("StoreCond32");
        return;
    case Opcode::StoreCondRel32:
        out.print("StoreCondRel32");
        return;
    case Opcode::LoadLink64:
        out.print("LoadLink64");
        return;
    case Opcode::LoadLinkAcq64:
        out.print("LoadLinkAcq64");
        return;
    case Opcode::StoreCond64:
        out.print("StoreCond64");
        return;
    case Opcode::StoreCondRel64:
        out.print("StoreCondRel64");
        return;
    case Opcode::Depend32:
        out.print("Depend32");
        return;
    case Opcode::Depend64:
        out.print("Depend64");
        return;
    case Opcode::Compare32:
        out.print("Compare32");
        return;
    case Opcode::Compare64:
        out.print("Compare64");
        return;
    case Opcode::Test32:
        out.print("Test32");
        return;
    case Opcode::Test64:
        out.print("Test64");
        return;
    case Opcode::CompareDouble:
        out.print("CompareDouble");
        return;
    case Opcode::CompareFloat:
        out.print("CompareFloat");
        return;
    case Opcode::Branch8:
        out.print("Branch8");
        return;
    case Opcode::Branch32:
        out.print("Branch32");
        return;
    case Opcode::Branch64:
        out.print("Branch64");
        return;
    case Opcode::BranchTest8:
        out.print("BranchTest8");
        return;
    case Opcode::BranchTest32:
        out.print("BranchTest32");
        return;
    case Opcode::BranchTest64:
        out.print("BranchTest64");
        return;
    case Opcode::BranchDouble:
        out.print("BranchDouble");
        return;
    case Opcode::BranchFloat:
        out.print("BranchFloat");
        return;
    case Opcode::BranchAdd32:
        out.print("BranchAdd32");
        return;
    case Opcode::BranchAdd64:
        out.print("BranchAdd64");
        return;
    case Opcode::BranchMul32:
        out.print("BranchMul32");
        return;
    case Opcode::BranchMul64:
        out.print("BranchMul64");
        return;
    case Opcode::BranchSub32:
        out.print("BranchSub32");
        return;
    case Opcode::BranchSub64:
        out.print("BranchSub64");
        return;
    case Opcode::BranchNeg32:
        out.print("BranchNeg32");
        return;
    case Opcode::BranchNeg64:
        out.print("BranchNeg64");
        return;
    case Opcode::MoveConditionally32:
        out.print("MoveConditionally32");
        return;
    case Opcode::MoveConditionally64:
        out.print("MoveConditionally64");
        return;
    case Opcode::MoveConditionallyTest32:
        out.print("MoveConditionallyTest32");
        return;
    case Opcode::MoveConditionallyTest64:
        out.print("MoveConditionallyTest64");
        return;
    case Opcode::MoveConditionallyDouble:
        out.print("MoveConditionallyDouble");
        return;
    case Opcode::MoveConditionallyFloat:
        out.print("MoveConditionallyFloat");
        return;
    case Opcode::MoveDoubleConditionally32:
        out.print("MoveDoubleConditionally32");
        return;
    case Opcode::MoveDoubleConditionally64:
        out.print("MoveDoubleConditionally64");
        return;
    case Opcode::MoveDoubleConditionallyTest32:
        out.print("MoveDoubleConditionallyTest32");
        return;
    case Opcode::MoveDoubleConditionallyTest64:
        out.print("MoveDoubleConditionallyTest64");
        return;
    case Opcode::MoveDoubleConditionallyDouble:
        out.print("MoveDoubleConditionallyDouble");
        return;
    case Opcode::MoveDoubleConditionallyFloat:
        out.print("MoveDoubleConditionallyFloat");
        return;
    case Opcode::MemoryFence:
        out.print("MemoryFence");
        return;
    case Opcode::StoreFence:
        out.print("StoreFence");
        return;
    case Opcode::LoadFence:
        out.print("LoadFence");
        return;
    case Opcode::Jump:
        out.print("Jump");
        return;
    case Opcode::RetVoid:
        out.print("RetVoid");
        return;
    case Opcode::Ret32:
        out.print("Ret32");
        return;
    case Opcode::Ret64:
        out.print("Ret64");
        return;
    case Opcode::RetFloat:
        out.print("RetFloat");
        return;
    case Opcode::RetDouble:
        out.print("RetDouble");
        return;
    case Opcode::Oops:
        out.print("Oops");
        return;
    case Opcode::EntrySwitch:
        out.print("EntrySwitch");
        return;
    case Opcode::Shuffle:
        out.print("Shuffle");
        return;
    case Opcode::Patch:
        out.print("Patch");
        return;
    case Opcode::CCall:
        out.print("CCall");
        return;
    case Opcode::ColdCCall:
        out.print("ColdCCall");
        return;
    case Opcode::WasmBoundsCheck:
        out.print("WasmBoundsCheck");
        return;
    }
    RELEASE_ASSERT_NOT_REACHED();
}
} // namespace WTF
namespace JSC { namespace B3 { namespace Air {
const uint8_t g_formTable[4809] = {
// Nop 

// Invalid: Nop with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Nop with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add32 with numOperands = 0

// Invalid: Add32 with numOperands = 1
INVALID_INST_FORM, 
// Add32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Add32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Add32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add8 with numOperands = 0

// Invalid: Add8 with numOperands = 1
INVALID_INST_FORM, 
// Add8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: Add8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add16 with numOperands = 0

// Invalid: Add16 with numOperands = 1
INVALID_INST_FORM, 
// Add16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: Add16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add64 with numOperands = 0

// Invalid: Add64 with numOperands = 1
INVALID_INST_FORM, 
// Add64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Add64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Add64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Add64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddDouble with numOperands = 0

// Invalid: AddDouble with numOperands = 1
INVALID_INST_FORM, 
// AddDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// AddDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: AddDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddFloat with numOperands = 0

// Invalid: AddFloat with numOperands = 1
INVALID_INST_FORM, 
// AddFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// AddFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: AddFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AddFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub32 with numOperands = 0

// Invalid: Sub32 with numOperands = 1
INVALID_INST_FORM, 
// Sub32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Sub32 U:G:32, U:G:32, D:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: Sub32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub64 with numOperands = 0

// Invalid: Sub64 with numOperands = 1
INVALID_INST_FORM, 
// Sub64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Sub64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Sub64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Sub64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubDouble with numOperands = 0

// Invalid: SubDouble with numOperands = 1
INVALID_INST_FORM, 
// SubDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// SubDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: SubDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubFloat with numOperands = 0

// Invalid: SubFloat with numOperands = 1
INVALID_INST_FORM, 
// SubFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// SubFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: SubFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SubFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 0

// Neg32 UZD:G:32
ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Invalid: Neg32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 0

// Neg64 UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: Neg64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Neg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateDouble with numOperands = 0

// Invalid: NegateDouble with numOperands = 1
INVALID_INST_FORM, 
// NegateDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: NegateDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateFloat with numOperands = 0

// Invalid: NegateFloat with numOperands = 1
INVALID_INST_FORM, 
// NegateFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: NegateFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: NegateFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul32 with numOperands = 0

// Invalid: Mul32 with numOperands = 1
INVALID_INST_FORM, 
// Mul32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Mul32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Mul32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul64 with numOperands = 0

// Invalid: Mul64 with numOperands = 1
INVALID_INST_FORM, 
// Mul64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Mul64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Mul64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Mul64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd32 with numOperands = 0

// Invalid: MultiplyAdd32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyAdd32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyAdd32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: MultiplyAdd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd64 with numOperands = 0

// Invalid: MultiplyAdd64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyAdd64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyAdd64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplyAdd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyAdd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub32 with numOperands = 0

// Invalid: MultiplySub32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplySub32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplySub32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: MultiplySub32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub64 with numOperands = 0

// Invalid: MultiplySub64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplySub64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplySub64 U:G:64, U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MultiplySub64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplySub64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg32 with numOperands = 0

// Invalid: MultiplyNeg32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyNeg32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyNeg32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: MultiplyNeg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg64 with numOperands = 0

// Invalid: MultiplyNeg64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MultiplyNeg64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// MultiplyNeg64 U:G:64, U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: MultiplyNeg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MultiplyNeg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div32 with numOperands = 0

// Invalid: Div32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Div32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Div32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Div32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv32 with numOperands = 0

// Invalid: UDiv32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: UDiv32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// UDiv32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: UDiv32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div64 with numOperands = 0

// Invalid: Div64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Div64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Div64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Div64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Div64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv64 with numOperands = 0

// Invalid: UDiv64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: UDiv64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// UDiv64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: UDiv64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: UDiv64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulDouble with numOperands = 0

// Invalid: MulDouble with numOperands = 1
INVALID_INST_FORM, 
// MulDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// MulDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MulDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulFloat with numOperands = 0

// Invalid: MulFloat with numOperands = 1
INVALID_INST_FORM, 
// MulFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// MulFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: MulFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MulFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivDouble with numOperands = 0

// Invalid: DivDouble with numOperands = 1
INVALID_INST_FORM, 
// DivDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// DivDouble U:F:64, U:F:32, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: DivDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivFloat with numOperands = 0

// Invalid: DivFloat with numOperands = 1
INVALID_INST_FORM, 
// DivFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// DivFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: DivFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: DivFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 0

// Invalid: X86ConvertToDoubleWord32 with numOperands = 1
INVALID_INST_FORM, 
// X86ConvertToDoubleWord32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToDoubleWord32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToQuadWord64 with numOperands = 0

// Invalid: X86ConvertToQuadWord64 with numOperands = 1
INVALID_INST_FORM, 
// X86ConvertToQuadWord64 U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: X86ConvertToQuadWord64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToQuadWord64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToQuadWord64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86ConvertToQuadWord64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div32 with numOperands = 0

// Invalid: X86Div32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86Div32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86Div32 UZD:G:32, UZD:G:32, U:G:32
ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: X86Div32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv32 with numOperands = 0

// Invalid: X86UDiv32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86UDiv32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86UDiv32 UZD:G:32, UZD:G:32, U:G:32
ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: X86UDiv32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div64 with numOperands = 0

// Invalid: X86Div64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86Div64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86Div64 UZD:G:64, UZD:G:64, U:G:64
ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: X86Div64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86Div64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv64 with numOperands = 0

// Invalid: X86UDiv64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: X86UDiv64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// X86UDiv64 UZD:G:64, UZD:G:64, U:G:64
ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: X86UDiv64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: X86UDiv64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea32 with numOperands = 0

// Invalid: Lea32 with numOperands = 1
INVALID_INST_FORM, 
// Lea32 UA:G:32, D:G:32
ENCODE_INST_FORM(Arg::UseAddr, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: Lea32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea64 with numOperands = 0

// Invalid: Lea64 with numOperands = 1
INVALID_INST_FORM, 
// Lea64 UA:G:64, D:G:64
ENCODE_INST_FORM(Arg::UseAddr, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Lea64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lea64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And32 with numOperands = 0

// Invalid: And32 with numOperands = 1
INVALID_INST_FORM, 
// And32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// And32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: And32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And64 with numOperands = 0

// Invalid: And64 with numOperands = 1
INVALID_INST_FORM, 
// And64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// And64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: And64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: And64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndDouble with numOperands = 0

// Invalid: AndDouble with numOperands = 1
INVALID_INST_FORM, 
// AndDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// AndDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: AndDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndFloat with numOperands = 0

// Invalid: AndFloat with numOperands = 1
INVALID_INST_FORM, 
// AndFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// AndFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: AndFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AndFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrDouble with numOperands = 0

// Invalid: OrDouble with numOperands = 1
INVALID_INST_FORM, 
// OrDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// OrDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: OrDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrFloat with numOperands = 0

// Invalid: OrFloat with numOperands = 1
INVALID_INST_FORM, 
// OrFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// OrFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: OrFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: OrFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorDouble with numOperands = 0

// Invalid: XorDouble with numOperands = 1
INVALID_INST_FORM, 
// XorDouble U:F:64, UD:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::UseDef, FP, Width64), 
// XorDouble U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: XorDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorFloat with numOperands = 0

// Invalid: XorFloat with numOperands = 1
INVALID_INST_FORM, 
// XorFloat U:F:32, UD:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::UseDef, FP, Width32), 
// XorFloat U:F:32, U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: XorFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: XorFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift32 with numOperands = 0

// Invalid: Lshift32 with numOperands = 1
INVALID_INST_FORM, 
// Lshift32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Lshift32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Lshift32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift64 with numOperands = 0

// Invalid: Lshift64 with numOperands = 1
INVALID_INST_FORM, 
// Lshift64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Lshift64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Lshift64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Lshift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift32 with numOperands = 0

// Invalid: Rshift32 with numOperands = 1
INVALID_INST_FORM, 
// Rshift32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Rshift32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Rshift32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift64 with numOperands = 0

// Invalid: Rshift64 with numOperands = 1
INVALID_INST_FORM, 
// Rshift64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Rshift64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Rshift64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Rshift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift32 with numOperands = 0

// Invalid: Urshift32 with numOperands = 1
INVALID_INST_FORM, 
// Urshift32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Urshift32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Urshift32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift64 with numOperands = 0

// Invalid: Urshift64 with numOperands = 1
INVALID_INST_FORM, 
// Urshift64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Urshift64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Urshift64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Urshift64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight32 with numOperands = 0

// Invalid: RotateRight32 with numOperands = 1
INVALID_INST_FORM, 
// RotateRight32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// RotateRight32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: RotateRight32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight64 with numOperands = 0

// Invalid: RotateRight64 with numOperands = 1
INVALID_INST_FORM, 
// RotateRight64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// RotateRight64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: RotateRight64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateRight64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft32 with numOperands = 0

// Invalid: RotateLeft32 with numOperands = 1
INVALID_INST_FORM, 
// RotateLeft32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Invalid: RotateLeft32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft64 with numOperands = 0

// Invalid: RotateLeft64 with numOperands = 1
INVALID_INST_FORM, 
// RotateLeft64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: RotateLeft64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RotateLeft64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or32 with numOperands = 0

// Invalid: Or32 with numOperands = 1
INVALID_INST_FORM, 
// Or32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Or32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Or32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or64 with numOperands = 0

// Invalid: Or64 with numOperands = 1
INVALID_INST_FORM, 
// Or64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Or64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Or64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Or64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor32 with numOperands = 0

// Invalid: Xor32 with numOperands = 1
INVALID_INST_FORM, 
// Xor32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Xor32 U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Xor32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor64 with numOperands = 0

// Invalid: Xor64 with numOperands = 1
INVALID_INST_FORM, 
// Xor64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Xor64 U:G:64, U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Xor64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xor64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not32 with numOperands = 0

// Not32 UZD:G:32
ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Not32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Not32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not64 with numOperands = 0

// Not64 UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Not64 U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: Not64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Not64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsDouble with numOperands = 0

// Invalid: AbsDouble with numOperands = 1
INVALID_INST_FORM, 
// AbsDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: AbsDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsFloat with numOperands = 0

// Invalid: AbsFloat with numOperands = 1
INVALID_INST_FORM, 
// AbsFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: AbsFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AbsFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilDouble with numOperands = 0

// Invalid: CeilDouble with numOperands = 1
INVALID_INST_FORM, 
// CeilDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: CeilDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilFloat with numOperands = 0

// Invalid: CeilFloat with numOperands = 1
INVALID_INST_FORM, 
// CeilFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: CeilFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CeilFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorDouble with numOperands = 0

// Invalid: FloorDouble with numOperands = 1
INVALID_INST_FORM, 
// FloorDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: FloorDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorFloat with numOperands = 0

// Invalid: FloorFloat with numOperands = 1
INVALID_INST_FORM, 
// FloorFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: FloorFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: FloorFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtDouble with numOperands = 0

// Invalid: SqrtDouble with numOperands = 1
INVALID_INST_FORM, 
// SqrtDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: SqrtDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtFloat with numOperands = 0

// Invalid: SqrtFloat with numOperands = 1
INVALID_INST_FORM, 
// SqrtFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: SqrtFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SqrtFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToDouble with numOperands = 0

// Invalid: ConvertInt32ToDouble with numOperands = 1
INVALID_INST_FORM, 
// ConvertInt32ToDouble U:G:32, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: ConvertInt32ToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToDouble with numOperands = 0

// Invalid: ConvertInt64ToDouble with numOperands = 1
INVALID_INST_FORM, 
// ConvertInt64ToDouble U:G:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: ConvertInt64ToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToFloat with numOperands = 0

// Invalid: ConvertInt32ToFloat with numOperands = 1
INVALID_INST_FORM, 
// ConvertInt32ToFloat U:G:32, D:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: ConvertInt32ToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt32ToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToFloat with numOperands = 0

// Invalid: ConvertInt64ToFloat with numOperands = 1
INVALID_INST_FORM, 
// ConvertInt64ToFloat U:G:64, D:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: ConvertInt64ToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertInt64ToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros32 with numOperands = 0

// Invalid: CountLeadingZeros32 with numOperands = 1
INVALID_INST_FORM, 
// CountLeadingZeros32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: CountLeadingZeros32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros64 with numOperands = 0

// Invalid: CountLeadingZeros64 with numOperands = 1
INVALID_INST_FORM, 
// CountLeadingZeros64 U:G:64, D:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: CountLeadingZeros64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CountLeadingZeros64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertDoubleToFloat with numOperands = 0

// Invalid: ConvertDoubleToFloat with numOperands = 1
INVALID_INST_FORM, 
// ConvertDoubleToFloat U:F:64, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: ConvertDoubleToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertDoubleToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertDoubleToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertDoubleToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertFloatToDouble with numOperands = 0

// Invalid: ConvertFloatToDouble with numOperands = 1
INVALID_INST_FORM, 
// ConvertFloatToDouble U:F:32, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: ConvertFloatToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertFloatToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertFloatToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ConvertFloatToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move with numOperands = 0

// Invalid: Move with numOperands = 1
INVALID_INST_FORM, 
// Move U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Def, GP, POINTER_WIDTH), 
// Move U:G:Ptr, D:G:Ptr, S:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Def, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Scratch, GP, POINTER_WIDTH), 
// Invalid: Move with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap32 with numOperands = 0

// Invalid: Swap32 with numOperands = 1
INVALID_INST_FORM, 
// Swap32 UD:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: Swap32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap64 with numOperands = 0

// Invalid: Swap64 with numOperands = 1
INVALID_INST_FORM, 
// Swap64 UD:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: Swap64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Swap64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32 with numOperands = 0

// Invalid: Move32 with numOperands = 1
INVALID_INST_FORM, 
// Move32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Move32 U:G:32, ZD:G:32, S:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), ENCODE_INST_FORM(Arg::Scratch, GP, Width32), 
// Invalid: Move32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero32 with numOperands = 0

// StoreZero32 D:G:32
ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: StoreZero32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero64 with numOperands = 0

// StoreZero64 D:G:64
ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: StoreZero64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreZero64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend32ToPtr with numOperands = 0

// Invalid: SignExtend32ToPtr with numOperands = 1
INVALID_INST_FORM, 
// SignExtend32ToPtr U:G:32, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, POINTER_WIDTH), 
// Invalid: SignExtend32ToPtr with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend32ToPtr with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend32ToPtr with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend32ToPtr with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend8To32 with numOperands = 0

// Invalid: ZeroExtend8To32 with numOperands = 1
INVALID_INST_FORM, 
// ZeroExtend8To32 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: ZeroExtend8To32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend8To32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend8To32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend8To32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To32 with numOperands = 0

// Invalid: SignExtend8To32 with numOperands = 1
INVALID_INST_FORM, 
// SignExtend8To32 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: SignExtend8To32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend8To32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend16To32 with numOperands = 0

// Invalid: ZeroExtend16To32 with numOperands = 1
INVALID_INST_FORM, 
// ZeroExtend16To32 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: ZeroExtend16To32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend16To32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend16To32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ZeroExtend16To32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To32 with numOperands = 0

// Invalid: SignExtend16To32 with numOperands = 1
INVALID_INST_FORM, 
// SignExtend16To32 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: SignExtend16To32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: SignExtend16To32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloat with numOperands = 0

// Invalid: MoveFloat with numOperands = 1
INVALID_INST_FORM, 
// MoveFloat U:F:32, D:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// MoveFloat U:F:32, D:F:32, S:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), ENCODE_INST_FORM(Arg::Scratch, FP, Width32), 
// Invalid: MoveFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDouble with numOperands = 0

// Invalid: MoveDouble with numOperands = 1
INVALID_INST_FORM, 
// MoveDouble U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// MoveDouble U:F:64, D:F:64, S:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), ENCODE_INST_FORM(Arg::Scratch, FP, Width64), 
// Invalid: MoveDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 0

// MoveZeroToDouble D:F:64
ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveZeroToDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveZeroToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move64ToDouble with numOperands = 0

// Invalid: Move64ToDouble with numOperands = 1
INVALID_INST_FORM, 
// Move64ToDouble U:G:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: Move64ToDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move64ToDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move64ToDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move64ToDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToFloat with numOperands = 0

// Invalid: Move32ToFloat with numOperands = 1
INVALID_INST_FORM, 
// Move32ToFloat U:G:32, D:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, FP, Width32), 
// Invalid: Move32ToFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Move32ToFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleTo64 with numOperands = 0

// Invalid: MoveDoubleTo64 with numOperands = 1
INVALID_INST_FORM, 
// MoveDoubleTo64 U:F:64, D:G:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), 
// Invalid: MoveDoubleTo64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleTo64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleTo64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleTo64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloatTo32 with numOperands = 0

// Invalid: MoveFloatTo32 with numOperands = 1
INVALID_INST_FORM, 
// MoveFloatTo32 U:F:32, D:G:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), 
// Invalid: MoveFloatTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloatTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloatTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveFloatTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8 with numOperands = 0

// Invalid: Load8 with numOperands = 1
INVALID_INST_FORM, 
// Load8 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Load8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8 with numOperands = 0

// Invalid: LoadAcq8 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq8 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store8 with numOperands = 0

// Invalid: Store8 with numOperands = 1
INVALID_INST_FORM, 
// Store8 U:G:8, D:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, GP, Width8), 
// Invalid: Store8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel8 with numOperands = 0

// Invalid: StoreRel8 with numOperands = 1
INVALID_INST_FORM, 
// StoreRel8 U:G:8, D:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, GP, Width8), 
// Invalid: StoreRel8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8SignedExtendTo32 with numOperands = 0

// Invalid: Load8SignedExtendTo32 with numOperands = 1
INVALID_INST_FORM, 
// Load8SignedExtendTo32 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Load8SignedExtendTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8SignedExtendTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8SignedExtendTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load8SignedExtendTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 0

// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq8SignedExtendTo32 U:G:8, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq8SignedExtendTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16 with numOperands = 0

// Invalid: Load16 with numOperands = 1
INVALID_INST_FORM, 
// Load16 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Load16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16 with numOperands = 0

// Invalid: LoadAcq16 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq16 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16SignedExtendTo32 with numOperands = 0

// Invalid: Load16SignedExtendTo32 with numOperands = 1
INVALID_INST_FORM, 
// Load16SignedExtendTo32 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Load16SignedExtendTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16SignedExtendTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16SignedExtendTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Load16SignedExtendTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 0

// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq16SignedExtendTo32 U:G:16, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq16SignedExtendTo32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store16 with numOperands = 0

// Invalid: Store16 with numOperands = 1
INVALID_INST_FORM, 
// Store16 U:G:16, D:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, GP, Width16), 
// Invalid: Store16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Store16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel16 with numOperands = 0

// Invalid: StoreRel16 with numOperands = 1
INVALID_INST_FORM, 
// StoreRel16 U:G:16, D:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, GP, Width16), 
// Invalid: StoreRel16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq32 with numOperands = 0

// Invalid: LoadAcq32 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadAcq32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel32 with numOperands = 0

// Invalid: StoreRel32 with numOperands = 1
INVALID_INST_FORM, 
// StoreRel32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: StoreRel32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq64 with numOperands = 0

// Invalid: LoadAcq64 with numOperands = 1
INVALID_INST_FORM, 
// LoadAcq64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: LoadAcq64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadAcq64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel64 with numOperands = 0

// Invalid: StoreRel64 with numOperands = 1
INVALID_INST_FORM, 
// StoreRel64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: StoreRel64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreRel64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg8 with numOperands = 0

// Invalid: Xchg8 with numOperands = 1
INVALID_INST_FORM, 
// Xchg8 UD:G:8, UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: Xchg8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg16 with numOperands = 0

// Invalid: Xchg16 with numOperands = 1
INVALID_INST_FORM, 
// Xchg16 UD:G:16, UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: Xchg16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg32 with numOperands = 0

// Invalid: Xchg32 with numOperands = 1
INVALID_INST_FORM, 
// Xchg32 UD:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: Xchg32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg64 with numOperands = 0

// Invalid: Xchg64 with numOperands = 1
INVALID_INST_FORM, 
// Xchg64 UD:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: Xchg64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Xchg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS8 with numOperands = 0

// Invalid: AtomicStrongCAS8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS8 UD:G:8, U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicStrongCAS8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS8 U:G:32, UD:G:8, U:G:8, UD:G:8, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: AtomicStrongCAS8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS16 with numOperands = 0

// Invalid: AtomicStrongCAS16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS16 UD:G:16, U:G:32, UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicStrongCAS16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS16 U:G:32, UD:G:16, U:G:32, UD:G:16, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: AtomicStrongCAS16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS32 with numOperands = 0

// Invalid: AtomicStrongCAS32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS32 UD:G:32, U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicStrongCAS32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS32 U:G:32, UD:G:32, U:G:32, UD:G:32, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: AtomicStrongCAS32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS64 with numOperands = 0

// Invalid: AtomicStrongCAS64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: AtomicStrongCAS64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS64 UD:G:64, U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicStrongCAS64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// AtomicStrongCAS64 U:G:32, UD:G:64, U:G:64, UD:G:64, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: AtomicStrongCAS64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 0

// Invalid: BranchAtomicStrongCAS8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAtomicStrongCAS8 U:G:32, UD:G:8, U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 0

// Invalid: BranchAtomicStrongCAS16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAtomicStrongCAS16 U:G:32, UD:G:16, U:G:32, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 0

// Invalid: BranchAtomicStrongCAS32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAtomicStrongCAS32 U:G:32, UD:G:32, U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 0

// Invalid: BranchAtomicStrongCAS64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAtomicStrongCAS64 U:G:32, UD:G:64, U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAtomicStrongCAS64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd8 with numOperands = 0

// Invalid: AtomicAdd8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAdd8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicAdd8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd16 with numOperands = 0

// Invalid: AtomicAdd16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAdd16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicAdd16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd32 with numOperands = 0

// Invalid: AtomicAdd32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAdd32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicAdd32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd64 with numOperands = 0

// Invalid: AtomicAdd64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAdd64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicAdd64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAdd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub8 with numOperands = 0

// Invalid: AtomicSub8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicSub8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicSub8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub16 with numOperands = 0

// Invalid: AtomicSub16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicSub16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicSub16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub32 with numOperands = 0

// Invalid: AtomicSub32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicSub32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicSub32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub64 with numOperands = 0

// Invalid: AtomicSub64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicSub64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicSub64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicSub64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd8 with numOperands = 0

// Invalid: AtomicAnd8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAnd8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicAnd8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd16 with numOperands = 0

// Invalid: AtomicAnd16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAnd16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicAnd16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd32 with numOperands = 0

// Invalid: AtomicAnd32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAnd32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicAnd32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd64 with numOperands = 0

// Invalid: AtomicAnd64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicAnd64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicAnd64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicAnd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr8 with numOperands = 0

// Invalid: AtomicOr8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicOr8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicOr8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr16 with numOperands = 0

// Invalid: AtomicOr16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicOr16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicOr16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr32 with numOperands = 0

// Invalid: AtomicOr32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicOr32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicOr32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr64 with numOperands = 0

// Invalid: AtomicOr64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicOr64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicOr64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicOr64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor8 with numOperands = 0

// Invalid: AtomicXor8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXor8 U:G:8, UD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicXor8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor16 with numOperands = 0

// Invalid: AtomicXor16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXor16 U:G:16, UD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicXor16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor32 with numOperands = 0

// Invalid: AtomicXor32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXor32 U:G:32, UD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicXor32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor64 with numOperands = 0

// Invalid: AtomicXor64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXor64 U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicXor64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXor64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 0

// AtomicNeg8 UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicNeg8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 0

// AtomicNeg16 UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicNeg16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 0

// AtomicNeg32 UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicNeg32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 0

// AtomicNeg64 UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicNeg64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNeg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 0

// AtomicNot8 UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicNot8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 0

// AtomicNot16 UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicNot16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 0

// AtomicNot32 UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicNot32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 0

// AtomicNot64 UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicNot64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicNot64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd8 with numOperands = 0

// Invalid: AtomicXchgAdd8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchgAdd8 UD:G:8, UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicXchgAdd8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd16 with numOperands = 0

// Invalid: AtomicXchgAdd16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchgAdd16 UD:G:16, UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicXchgAdd16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd32 with numOperands = 0

// Invalid: AtomicXchgAdd32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchgAdd32 UD:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicXchgAdd32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd64 with numOperands = 0

// Invalid: AtomicXchgAdd64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchgAdd64 UD:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicXchgAdd64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchgAdd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg8 with numOperands = 0

// Invalid: AtomicXchg8 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchg8 UD:G:8, UD:G:8
ENCODE_INST_FORM(Arg::UseDef, GP, Width8), ENCODE_INST_FORM(Arg::UseDef, GP, Width8), 
// Invalid: AtomicXchg8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg16 with numOperands = 0

// Invalid: AtomicXchg16 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchg16 UD:G:16, UD:G:16
ENCODE_INST_FORM(Arg::UseDef, GP, Width16), ENCODE_INST_FORM(Arg::UseDef, GP, Width16), 
// Invalid: AtomicXchg16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg32 with numOperands = 0

// Invalid: AtomicXchg32 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchg32 UD:G:32, UD:G:32
ENCODE_INST_FORM(Arg::UseDef, GP, Width32), ENCODE_INST_FORM(Arg::UseDef, GP, Width32), 
// Invalid: AtomicXchg32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg64 with numOperands = 0

// Invalid: AtomicXchg64 with numOperands = 1
INVALID_INST_FORM, 
// AtomicXchg64 UD:G:64, UD:G:64
ENCODE_INST_FORM(Arg::UseDef, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: AtomicXchg64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: AtomicXchg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink8 with numOperands = 0

// Invalid: LoadLink8 with numOperands = 1
INVALID_INST_FORM, 
// LoadLink8 U:G:8, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: LoadLink8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq8 with numOperands = 0

// Invalid: LoadLinkAcq8 with numOperands = 1
INVALID_INST_FORM, 
// LoadLinkAcq8 U:G:8, ZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::ZDef, GP, Width8), 
// Invalid: LoadLinkAcq8 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond8 with numOperands = 0

// Invalid: StoreCond8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCond8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCond8 U:G:8, D:G:8, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, GP, Width8), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCond8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel8 with numOperands = 0

// Invalid: StoreCondRel8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCondRel8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCondRel8 U:G:8, D:G:8, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Def, GP, Width8), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCondRel8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink16 with numOperands = 0

// Invalid: LoadLink16 with numOperands = 1
INVALID_INST_FORM, 
// LoadLink16 U:G:16, ZD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width16), 
// Invalid: LoadLink16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq16 with numOperands = 0

// Invalid: LoadLinkAcq16 with numOperands = 1
INVALID_INST_FORM, 
// LoadLinkAcq16 U:G:16, ZD:G:16
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::ZDef, GP, Width16), 
// Invalid: LoadLinkAcq16 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond16 with numOperands = 0

// Invalid: StoreCond16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCond16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCond16 U:G:16, D:G:16, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, GP, Width16), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCond16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel16 with numOperands = 0

// Invalid: StoreCondRel16 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCondRel16 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCondRel16 U:G:16, D:G:16, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width16), ENCODE_INST_FORM(Arg::Def, GP, Width16), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCondRel16 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel16 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel16 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink32 with numOperands = 0

// Invalid: LoadLink32 with numOperands = 1
INVALID_INST_FORM, 
// LoadLink32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadLink32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq32 with numOperands = 0

// Invalid: LoadLinkAcq32 with numOperands = 1
INVALID_INST_FORM, 
// LoadLinkAcq32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: LoadLinkAcq32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond32 with numOperands = 0

// Invalid: StoreCond32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCond32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCond32 U:G:32, D:G:32, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCond32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel32 with numOperands = 0

// Invalid: StoreCondRel32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCondRel32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCondRel32 U:G:32, D:G:32, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Def, GP, Width32), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCondRel32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink64 with numOperands = 0

// Invalid: LoadLink64 with numOperands = 1
INVALID_INST_FORM, 
// LoadLink64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: LoadLink64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLink64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq64 with numOperands = 0

// Invalid: LoadLinkAcq64 with numOperands = 1
INVALID_INST_FORM, 
// LoadLinkAcq64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: LoadLinkAcq64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadLinkAcq64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond64 with numOperands = 0

// Invalid: StoreCond64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCond64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCond64 U:G:64, D:G:64, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCond64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCond64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel64 with numOperands = 0

// Invalid: StoreCondRel64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreCondRel64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreCondRel64 U:G:64, D:G:64, EZD:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Def, GP, Width64), ENCODE_INST_FORM(Arg::EarlyZDef, GP, Width8), 
// Invalid: StoreCondRel64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreCondRel64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend32 with numOperands = 0

// Invalid: Depend32 with numOperands = 1
INVALID_INST_FORM, 
// Depend32 U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Depend32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend64 with numOperands = 0

// Invalid: Depend64 with numOperands = 1
INVALID_INST_FORM, 
// Depend64 U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: Depend64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Depend64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare32 with numOperands = 0

// Invalid: Compare32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Compare32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Compare32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Compare32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare64 with numOperands = 0

// Invalid: Compare64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Compare64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Compare64 U:G:32, U:G:64, U:G:64, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Compare64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Compare64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test32 with numOperands = 0

// Invalid: Test32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Test32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Test32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Test32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test64 with numOperands = 0

// Invalid: Test64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Test64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Test64 U:G:32, U:G:64, U:G:64, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: Test64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Test64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareDouble with numOperands = 0

// Invalid: CompareDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareDouble U:G:32, U:F:64, U:F:64, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: CompareDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloat with numOperands = 0

// Invalid: CompareFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CompareFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// CompareFloat U:G:32, U:F:32, U:F:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: CompareFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CompareFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch8 with numOperands = 0

// Invalid: Branch8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Branch8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Branch8 U:G:32, U:G:8, U:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: Branch8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch32 with numOperands = 0

// Invalid: Branch32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Branch32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Branch32 U:G:32, U:G:32, U:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: Branch32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch64 with numOperands = 0

// Invalid: Branch64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Branch64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Branch64 U:G:32, U:G:64, U:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: Branch64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Branch64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest8 with numOperands = 0

// Invalid: BranchTest8 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchTest8 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchTest8 U:G:32, U:G:8, U:G:8
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width8), ENCODE_INST_FORM(Arg::Use, GP, Width8), 
// Invalid: BranchTest8 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest8 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest8 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest32 with numOperands = 0

// Invalid: BranchTest32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchTest32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchTest32 U:G:32, U:G:32, U:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: BranchTest32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest64 with numOperands = 0

// Invalid: BranchTest64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchTest64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchTest64 U:G:32, U:G:64, U:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: BranchTest64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchTest64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDouble with numOperands = 0

// Invalid: BranchDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchDouble U:G:32, U:F:64, U:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), 
// Invalid: BranchDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloat with numOperands = 0

// Invalid: BranchFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchFloat U:G:32, U:F:32, U:F:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), 
// Invalid: BranchFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAdd32 with numOperands = 0

// Invalid: BranchAdd32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAdd32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAdd32 U:G:32, U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// BranchAdd32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: BranchAdd32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAdd32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAdd64 with numOperands = 0

// Invalid: BranchAdd64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchAdd64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchAdd64 U:G:32, U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// BranchAdd64 U:G:32, U:G:64, U:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: BranchAdd64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchAdd64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchMul32 with numOperands = 0

// Invalid: BranchMul32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchMul32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchMul32 U:G:32, U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// BranchMul32 U:G:32, U:G:32, U:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: BranchMul32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchMul32 U:G:32, U:G:32, U:G:32, S:G:32, S:G:32, ZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Scratch, GP, Width32), ENCODE_INST_FORM(Arg::Scratch, GP, Width32), ENCODE_INST_FORM(Arg::ZDef, GP, Width32), 
// Invalid: BranchMul64 with numOperands = 0

// Invalid: BranchMul64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchMul64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchMul64 U:G:32, U:G:64, UZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), 
// Invalid: BranchMul64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchMul64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchMul64 U:G:32, U:G:64, U:G:64, S:G:64, S:G:64, ZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::Scratch, GP, Width64), ENCODE_INST_FORM(Arg::ZDef, GP, Width64), 
// Invalid: BranchSub32 with numOperands = 0

// Invalid: BranchSub32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchSub32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchSub32 U:G:32, U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Invalid: BranchSub32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchSub32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchSub32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchSub64 with numOperands = 0

// Invalid: BranchSub64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: BranchSub64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// BranchSub64 U:G:32, U:G:64, UD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::UseDef, GP, Width64), 
// Invalid: BranchSub64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchSub64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchSub64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg32 with numOperands = 0

// Invalid: BranchNeg32 with numOperands = 1
INVALID_INST_FORM, 
// BranchNeg32 U:G:32, UZD:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width32), 
// Invalid: BranchNeg32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg64 with numOperands = 0

// Invalid: BranchNeg64 with numOperands = 1
INVALID_INST_FORM, 
// BranchNeg64 U:G:32, UZD:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::UseZDef, GP, Width64), 
// Invalid: BranchNeg64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: BranchNeg64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally32 with numOperands = 0

// Invalid: MoveConditionally32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionally32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionally32 U:G:32, U:G:32, U:G:32, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::UseDef, GP, POINTER_WIDTH), 
// MoveConditionally32 U:G:32, U:G:32, U:G:32, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Def, GP, POINTER_WIDTH), 
// Invalid: MoveConditionally64 with numOperands = 0

// Invalid: MoveConditionally64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionally64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionally64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionally64 U:G:32, U:G:64, U:G:64, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::UseDef, GP, POINTER_WIDTH), 
// MoveConditionally64 U:G:32, U:G:64, U:G:64, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Def, GP, POINTER_WIDTH), 
// Invalid: MoveConditionallyTest32 with numOperands = 0

// Invalid: MoveConditionallyTest32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyTest32 U:G:32, U:G:32, U:G:32, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::UseDef, GP, POINTER_WIDTH), 
// MoveConditionallyTest32 U:G:32, U:G:32, U:G:32, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Def, GP, POINTER_WIDTH), 
// Invalid: MoveConditionallyTest64 with numOperands = 0

// Invalid: MoveConditionallyTest64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyTest64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyTest64 U:G:32, U:G:64, U:G:64, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::UseDef, GP, POINTER_WIDTH), 
// MoveConditionallyTest64 U:G:32, U:G:32, U:G:32, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Def, GP, POINTER_WIDTH), 
// Invalid: MoveConditionallyDouble with numOperands = 0

// Invalid: MoveConditionallyDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyDouble U:G:32, U:F:64, U:F:64, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::UseDef, GP, POINTER_WIDTH), 
// MoveConditionallyDouble U:G:32, U:F:64, U:F:64, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Def, GP, POINTER_WIDTH), 
// Invalid: MoveConditionallyFloat with numOperands = 0

// Invalid: MoveConditionallyFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveConditionallyFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveConditionallyFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveConditionallyFloat U:G:32, U:F:32, U:F:32, U:G:Ptr, UD:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::UseDef, GP, POINTER_WIDTH), 
// MoveConditionallyFloat U:G:32, U:F:32, U:F:32, U:G:Ptr, U:G:Ptr, D:G:Ptr
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Use, GP, POINTER_WIDTH), ENCODE_INST_FORM(Arg::Def, GP, POINTER_WIDTH), 
// Invalid: MoveDoubleConditionally32 with numOperands = 0

// Invalid: MoveDoubleConditionally32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionally32 U:G:32, U:G:32, U:G:32, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionally64 with numOperands = 0

// Invalid: MoveDoubleConditionally64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionally64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionally64 U:G:32, U:G:64, U:G:64, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 0

// Invalid: MoveDoubleConditionallyTest32 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyTest32 U:G:32, U:G:32, U:G:32, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 0

// Invalid: MoveDoubleConditionallyTest64 with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyTest64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyTest64 U:G:32, U:G:64, U:G:64, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, GP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 0

// Invalid: MoveDoubleConditionallyDouble with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyDouble U:G:32, U:F:64, U:F:64, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 0

// Invalid: MoveDoubleConditionallyFloat with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MoveDoubleConditionallyFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// MoveDoubleConditionallyFloat U:G:32, U:F:32, U:F:32, U:F:64, U:F:64, D:F:64
ENCODE_INST_FORM(Arg::Use, GP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width32), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Use, FP, Width64), ENCODE_INST_FORM(Arg::Def, FP, Width64), 
// MemoryFence 

// Invalid: MemoryFence with numOperands = 1
INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: MemoryFence with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// StoreFence 

// Invalid: StoreFence with numOperands = 1
INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: StoreFence with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// LoadFence 

// Invalid: LoadFence with numOperands = 1
INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: LoadFence with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Jump 

// Invalid: Jump with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Jump with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// RetVoid 

// Invalid: RetVoid with numOperands = 1
INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetVoid with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 0

// Ret32 U:G:32
ENCODE_INST_FORM(Arg::Use, GP, Width32), 
// Invalid: Ret32 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret32 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 0

// Ret64 U:G:64
ENCODE_INST_FORM(Arg::Use, GP, Width64), 
// Invalid: Ret64 with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Ret64 with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 0

// RetFloat U:F:32
ENCODE_INST_FORM(Arg::Use, FP, Width32), 
// Invalid: RetFloat with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetFloat with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 0

// RetDouble U:F:64
ENCODE_INST_FORM(Arg::Use, FP, Width64), 
// Invalid: RetDouble with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: RetDouble with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Oops 

// Invalid: Oops with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Oops with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 0

// Invalid: EntrySwitch with numOperands = 1
INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: EntrySwitch with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 0

// Invalid: Shuffle with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Shuffle with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 0

// Invalid: Patch with numOperands = 1
INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: Patch with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 0

// Invalid: CCall with numOperands = 1
INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: CCall with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 0

// Invalid: ColdCCall with numOperands = 1
INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: ColdCCall with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 0

// Invalid: WasmBoundsCheck with numOperands = 1
INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 2
INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 3
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 4
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 5
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
// Invalid: WasmBoundsCheck with numOperands = 6
INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, INVALID_INST_FORM, 
};
void Inst::forEachArgCustom(ScopedLambda<EachArgCallback> lambda)
{
switch (kind.opcode) {
case Opcode::EntrySwitch:
EntrySwitchCustom::forEachArg(*this, lambda);
break;
case Opcode::Shuffle:
ShuffleCustom::forEachArg(*this, lambda);
break;
case Opcode::Patch:
PatchCustom::forEachArg(*this, lambda);
break;
case Opcode::CCall:
CCallCustom::forEachArg(*this, lambda);
break;
case Opcode::ColdCCall:
ColdCCallCustom::forEachArg(*this, lambda);
break;
case Opcode::WasmBoundsCheck:
WasmBoundsCheckCustom::forEachArg(*this, lambda);
break;
default:
dataLog("Bad call to forEachArgCustom, not custom opcode: ", kind, "\n");
RELEASE_ASSERT_NOT_REACHED();
}
}
bool Inst::isValidForm()
{
switch (this->kind.opcode) {
case Opcode::Nop:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::Add32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::NegateDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::NegateFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Mul64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplySub32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplySub64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNeg32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MultiplyNeg64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Div32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UDiv32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Div64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::UDiv64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToDoubleWord32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86ConvertToQuadWord64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86ConvertToQuadWord64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86Div32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86UDiv32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86UDiv32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86Div64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86Div64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86UDiv64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!isX86UDiv64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lea32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (args[0].isStack() && args[0].stackSlot()->isSpill())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lea64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (args[0].isStack() && args[0].stackSlot()->isSpill())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::And32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::And64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::OrFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::XorFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isLshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isUrshift64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateRight32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateRight64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateLeft32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!isRotateLeft64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Or32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Or64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!Arg::isValidBitImm64Form(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AbsDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AbsFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CeilDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CeilFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::FloorDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::FloorFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SqrtDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SqrtFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertDoubleToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ConvertFloatToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), POINTER_WIDTH))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BigImm:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), POINTER_WIDTH))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreZero32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreZero64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend32ToPtr:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ZeroExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend8To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::ZeroExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend16To32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveZeroToDouble:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move64ToDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32ToFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleTo64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveFloatTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARMv7) || CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Store8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
#if CPU(ARMv7) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load8SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq8SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARMv7) || CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARMv7) || CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Load16SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq16SignedExtendTo32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARMv7) || CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Store16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
#if CPU(ARMv7) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARMv7) || CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
#if CPU(ARMv7) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadAcq64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS8:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width8))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[2].scale(), args[2].offset(), Width8))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width16))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[2].scale(), args[2].offset(), Width16))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width32))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[2].scale(), args[2].offset(), Width32))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width64))
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[2].scale(), args[2].offset(), Width64))
OPGEN_RETURN(false);
if (!isAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width8))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS8Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS16:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width16))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS16Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width32))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS32Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::StatusCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[3].offset()))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[3].scale(), args[3].offset(), Width64))
OPGEN_RETURN(false);
if (!isBranchAtomicStrongCAS64Valid(*this))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidImmForm(args[0].value()))
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg8:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg16:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot8:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot16:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[0].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[0].scale(), args[0].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width16))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq8:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq16:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel16:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::SimpleAddr:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].ptr().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCond64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreCondRel64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::SimpleAddr:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].ptr().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Depend32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Depend64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Compare32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Compare64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Test32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Test64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareDouble:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::CompareFloat:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Imm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest8:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width8))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::BitImm:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImm64Form(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
#endif // USE(JSVALUE64)
case Arg::BitImm:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchSub32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchSub64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!Arg::isValidImmForm(args[1].value()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchNeg32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchNeg64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionally32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionally64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
if (!args[5].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 5:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isGP())
OPGEN_RETURN(false);
if (!args[4].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally32:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally64:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::RelCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidAddrForm(args[2].offset()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest32:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidBitImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width32))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest64:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::ResCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!args[1].tmp().isGP())
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidAddrForm(args[1].offset()))
OPGEN_RETURN(false);
if (!args[2].tmp().isGP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
switch (this->args[2].kind()) {
case Arg::Imm:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
if (!Arg::isValidIndexForm(args[1].scale(), args[1].offset(), Width64))
OPGEN_RETURN(false);
if (!Arg::isValidImmForm(args[2].value()))
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDouble:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyFloat:
switch (this->args.size()) {
case 6:
switch (this->args[0].kind()) {
case Arg::DoubleCond:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
switch (this->args[3].kind()) {
case Arg::Tmp:
switch (this->args[4].kind()) {
case Arg::Tmp:
switch (this->args[5].kind()) {
case Arg::Tmp:
if (!args[1].tmp().isFP())
OPGEN_RETURN(false);
if (!args[2].tmp().isFP())
OPGEN_RETURN(false);
if (!args[3].tmp().isFP())
OPGEN_RETURN(false);
if (!args[4].tmp().isFP())
OPGEN_RETURN(false);
if (!args[5].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MemoryFence:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::StoreFence:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::LoadFence:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::Jump:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::RetVoid:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::Ret32:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Ret64:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
if (!args[0].tmp().isGP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RetFloat:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RetDouble:
switch (this->args.size()) {
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
if (!args[0].tmp().isFP())
OPGEN_RETURN(false);
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Oops:
switch (this->args.size()) {
case 0:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::isValidForm(*this));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::isValidForm(*this));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::isValidForm(*this));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::isValidForm(*this));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::isValidForm(*this));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::isValidForm(*this));
break;
default:
break;
}
return false;
}
bool Inst::admitsStack(unsigned argIndex)
{
switch (kind.opcode) {
case Opcode::Nop:
switch (argIndex) {
default:
break;
}
break;
case Opcode::Add32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Add8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AddFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Sub32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Sub64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SubFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Neg32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::NegateDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::NegateFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Mul32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Mul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplySub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplySub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNeg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MultiplyNeg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Div32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::UDiv32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Div64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::UDiv64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MulDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MulFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::DivDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::DivFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86ConvertToQuadWord64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86Div32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86UDiv32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86Div64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::X86UDiv64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lea32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lea64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::And32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::And64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AndFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::OrFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::XorFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Lshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Rshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Rshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Urshift32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Urshift64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateRight32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateRight64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateLeft32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RotateLeft64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Or32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Or64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Xor32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 3:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::BitImm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Xor64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::Imm:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
case Arg::Tmp:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Not32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Not64:
switch (argIndex) {
case 0:
switch (args.size()) {
case 1:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AbsDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AbsFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CeilDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CeilFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::FloorDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::FloorFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SqrtDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SqrtFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertDoubleToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ConvertFloatToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
#if USE(JSVALUE64)
case Arg::BigImm:
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BigImm:
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Swap32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Swap64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Move32:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
case Arg::Imm:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreZero32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreZero64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SignExtend32ToPtr:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ZeroExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SignExtend8To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::ZeroExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::SignExtend16To32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveFloat:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDouble:
switch (argIndex) {
case 0:
switch (args.size()) {
case 2:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 1:
switch (args.size()) {
case 2:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(true);
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveZeroToDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move64ToDouble:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Move32ToFloat:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleTo64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveFloatTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Store8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load8SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq8SignedExtendTo32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Load16SignedExtendTo32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[1].kind()) {
case Arg::Tmp:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq16SignedExtendTo32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Store16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
OPGEN_RETURN(true);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Index:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreRel32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadAcq64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreRel64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Xchg8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xchg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::Tmp:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args.size()) {
case 5:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[4].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 4:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
switch (args[0].kind()) {
case Arg::StatusCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (args[2].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot8:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot16:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot32:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNot64:
switch (argIndex) {
case 0:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXchg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::LoadLink8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel16:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLink64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::LoadLinkAcq64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCond64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::StoreCondRel64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Depend32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Depend64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Compare32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Compare64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Test32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Test64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::CompareFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Branch8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Branch32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Branch64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchTest8:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::BitImm:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchAdd32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchAdd64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Imm:
break;
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args.size()) {
case 4:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchMul32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args.size()) {
case 3:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchMul64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchSub32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::ResCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchSub64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchNeg32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::BranchNeg64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::RelCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
switch (args[0].kind()) {
case Arg::RelCond:
switch (args[1].kind()) {
case Arg::Tmp:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Imm:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
switch (args[0].kind()) {
case Arg::ResCond:
switch (Arg::Addr) {
case Arg::Tmp:
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (args[2].kind()) {
case Arg::Imm:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Tmp:
switch (args[3].kind()) {
case Arg::Tmp:
switch (args[4].kind()) {
case Arg::Tmp:
switch (args[5].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
OPGEN_RETURN(true);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Arg::Index:
break;
default:
break;
}
break;
default:
break;
}
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
case 1:
OPGEN_RETURN(false);
break;
case 2:
OPGEN_RETURN(false);
break;
case 3:
OPGEN_RETURN(false);
break;
case 4:
OPGEN_RETURN(false);
break;
case 5:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::MemoryFence:
switch (argIndex) {
default:
break;
}
break;
case Opcode::StoreFence:
switch (argIndex) {
default:
break;
}
break;
case Opcode::LoadFence:
switch (argIndex) {
default:
break;
}
break;
case Opcode::Jump:
switch (argIndex) {
default:
break;
}
break;
case Opcode::RetVoid:
switch (argIndex) {
default:
break;
}
break;
case Opcode::Ret32:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Ret64:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RetFloat:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::RetDouble:
switch (argIndex) {
case 0:
OPGEN_RETURN(false);
break;
default:
break;
}
break;
case Opcode::Oops:
switch (argIndex) {
default:
break;
}
break;
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::admitsStack(*this, argIndex));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::admitsStack(*this, argIndex));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::admitsStack(*this, argIndex));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::admitsStack(*this, argIndex));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::admitsStack(*this, argIndex));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::admitsStack(*this, argIndex));
break;
default:
break;
}
return false;
}
bool Inst::admitsExtendedOffsetAddr(unsigned argIndex)
{
switch (kind.opcode) {
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::admitsExtendedOffsetAddr(*this, argIndex));
break;
default:
break;
}
return false;
}
bool Inst::isTerminal()
{
switch (kind.opcode) {
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::Branch8:
case Opcode::Branch32:
case Opcode::Branch64:
case Opcode::BranchTest8:
case Opcode::BranchTest32:
case Opcode::BranchTest64:
case Opcode::BranchDouble:
case Opcode::BranchFloat:
case Opcode::BranchAdd32:
case Opcode::BranchAdd64:
case Opcode::BranchMul32:
case Opcode::BranchMul64:
case Opcode::BranchSub32:
case Opcode::BranchSub64:
case Opcode::BranchNeg32:
case Opcode::BranchNeg64:
case Opcode::Jump:
case Opcode::RetVoid:
case Opcode::Ret32:
case Opcode::Ret64:
case Opcode::RetFloat:
case Opcode::RetDouble:
case Opcode::Oops:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom::isTerminal(*this);
case Opcode::Shuffle:
return ShuffleCustom::isTerminal(*this);
case Opcode::Patch:
return PatchCustom::isTerminal(*this);
case Opcode::CCall:
return CCallCustom::isTerminal(*this);
case Opcode::ColdCCall:
return ColdCCallCustom::isTerminal(*this);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom::isTerminal(*this);
default:
return false;
}
}
bool Inst::hasNonArgNonControlEffects()
{
if (kind.effects)
return true;
switch (kind.opcode) {
case Opcode::LoadAcq8:
case Opcode::StoreRel8:
case Opcode::LoadAcq8SignedExtendTo32:
case Opcode::LoadAcq16:
case Opcode::LoadAcq16SignedExtendTo32:
case Opcode::StoreRel16:
case Opcode::LoadAcq32:
case Opcode::StoreRel32:
case Opcode::LoadAcq64:
case Opcode::StoreRel64:
case Opcode::Xchg8:
case Opcode::Xchg16:
case Opcode::Xchg32:
case Opcode::Xchg64:
case Opcode::AtomicStrongCAS8:
case Opcode::AtomicStrongCAS16:
case Opcode::AtomicStrongCAS32:
case Opcode::AtomicStrongCAS64:
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::AtomicAdd8:
case Opcode::AtomicAdd16:
case Opcode::AtomicAdd32:
case Opcode::AtomicAdd64:
case Opcode::AtomicSub8:
case Opcode::AtomicSub16:
case Opcode::AtomicSub32:
case Opcode::AtomicSub64:
case Opcode::AtomicAnd8:
case Opcode::AtomicAnd16:
case Opcode::AtomicAnd32:
case Opcode::AtomicAnd64:
case Opcode::AtomicOr8:
case Opcode::AtomicOr16:
case Opcode::AtomicOr32:
case Opcode::AtomicOr64:
case Opcode::AtomicXor8:
case Opcode::AtomicXor16:
case Opcode::AtomicXor32:
case Opcode::AtomicXor64:
case Opcode::AtomicNeg8:
case Opcode::AtomicNeg16:
case Opcode::AtomicNeg32:
case Opcode::AtomicNeg64:
case Opcode::AtomicNot8:
case Opcode::AtomicNot16:
case Opcode::AtomicNot32:
case Opcode::AtomicNot64:
case Opcode::AtomicXchgAdd8:
case Opcode::AtomicXchgAdd16:
case Opcode::AtomicXchgAdd32:
case Opcode::AtomicXchgAdd64:
case Opcode::AtomicXchg8:
case Opcode::AtomicXchg16:
case Opcode::AtomicXchg32:
case Opcode::AtomicXchg64:
case Opcode::LoadLink8:
case Opcode::LoadLinkAcq8:
case Opcode::StoreCond8:
case Opcode::StoreCondRel8:
case Opcode::LoadLink16:
case Opcode::LoadLinkAcq16:
case Opcode::StoreCond16:
case Opcode::StoreCondRel16:
case Opcode::LoadLink32:
case Opcode::LoadLinkAcq32:
case Opcode::StoreCond32:
case Opcode::StoreCondRel32:
case Opcode::LoadLink64:
case Opcode::LoadLinkAcq64:
case Opcode::StoreCond64:
case Opcode::StoreCondRel64:
case Opcode::MemoryFence:
case Opcode::StoreFence:
case Opcode::LoadFence:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom::hasNonArgNonControlEffects(*this);
case Opcode::Shuffle:
return ShuffleCustom::hasNonArgNonControlEffects(*this);
case Opcode::Patch:
return PatchCustom::hasNonArgNonControlEffects(*this);
case Opcode::CCall:
return CCallCustom::hasNonArgNonControlEffects(*this);
case Opcode::ColdCCall:
return ColdCCallCustom::hasNonArgNonControlEffects(*this);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom::hasNonArgNonControlEffects(*this);
default:
return false;
}
}
bool Inst::hasNonArgEffects()
{
if (kind.effects)
return true;
switch (kind.opcode) {
case Opcode::LoadAcq8:
case Opcode::StoreRel8:
case Opcode::LoadAcq8SignedExtendTo32:
case Opcode::LoadAcq16:
case Opcode::LoadAcq16SignedExtendTo32:
case Opcode::StoreRel16:
case Opcode::LoadAcq32:
case Opcode::StoreRel32:
case Opcode::LoadAcq64:
case Opcode::StoreRel64:
case Opcode::Xchg8:
case Opcode::Xchg16:
case Opcode::Xchg32:
case Opcode::Xchg64:
case Opcode::AtomicStrongCAS8:
case Opcode::AtomicStrongCAS16:
case Opcode::AtomicStrongCAS32:
case Opcode::AtomicStrongCAS64:
case Opcode::BranchAtomicStrongCAS8:
case Opcode::BranchAtomicStrongCAS16:
case Opcode::BranchAtomicStrongCAS32:
case Opcode::BranchAtomicStrongCAS64:
case Opcode::AtomicAdd8:
case Opcode::AtomicAdd16:
case Opcode::AtomicAdd32:
case Opcode::AtomicAdd64:
case Opcode::AtomicSub8:
case Opcode::AtomicSub16:
case Opcode::AtomicSub32:
case Opcode::AtomicSub64:
case Opcode::AtomicAnd8:
case Opcode::AtomicAnd16:
case Opcode::AtomicAnd32:
case Opcode::AtomicAnd64:
case Opcode::AtomicOr8:
case Opcode::AtomicOr16:
case Opcode::AtomicOr32:
case Opcode::AtomicOr64:
case Opcode::AtomicXor8:
case Opcode::AtomicXor16:
case Opcode::AtomicXor32:
case Opcode::AtomicXor64:
case Opcode::AtomicNeg8:
case Opcode::AtomicNeg16:
case Opcode::AtomicNeg32:
case Opcode::AtomicNeg64:
case Opcode::AtomicNot8:
case Opcode::AtomicNot16:
case Opcode::AtomicNot32:
case Opcode::AtomicNot64:
case Opcode::AtomicXchgAdd8:
case Opcode::AtomicXchgAdd16:
case Opcode::AtomicXchgAdd32:
case Opcode::AtomicXchgAdd64:
case Opcode::AtomicXchg8:
case Opcode::AtomicXchg16:
case Opcode::AtomicXchg32:
case Opcode::AtomicXchg64:
case Opcode::LoadLink8:
case Opcode::LoadLinkAcq8:
case Opcode::StoreCond8:
case Opcode::StoreCondRel8:
case Opcode::LoadLink16:
case Opcode::LoadLinkAcq16:
case Opcode::StoreCond16:
case Opcode::StoreCondRel16:
case Opcode::LoadLink32:
case Opcode::LoadLinkAcq32:
case Opcode::StoreCond32:
case Opcode::StoreCondRel32:
case Opcode::LoadLink64:
case Opcode::LoadLinkAcq64:
case Opcode::StoreCond64:
case Opcode::StoreCondRel64:
case Opcode::Branch8:
case Opcode::Branch32:
case Opcode::Branch64:
case Opcode::BranchTest8:
case Opcode::BranchTest32:
case Opcode::BranchTest64:
case Opcode::BranchDouble:
case Opcode::BranchFloat:
case Opcode::BranchAdd32:
case Opcode::BranchAdd64:
case Opcode::BranchMul32:
case Opcode::BranchMul64:
case Opcode::BranchSub32:
case Opcode::BranchSub64:
case Opcode::BranchNeg32:
case Opcode::BranchNeg64:
case Opcode::MemoryFence:
case Opcode::StoreFence:
case Opcode::LoadFence:
case Opcode::Jump:
case Opcode::RetVoid:
case Opcode::Ret32:
case Opcode::Ret64:
case Opcode::RetFloat:
case Opcode::RetDouble:
case Opcode::Oops:
return true;
case Opcode::EntrySwitch:
return EntrySwitchCustom::hasNonArgEffects(*this);
case Opcode::Shuffle:
return ShuffleCustom::hasNonArgEffects(*this);
case Opcode::Patch:
return PatchCustom::hasNonArgEffects(*this);
case Opcode::CCall:
return CCallCustom::hasNonArgEffects(*this);
case Opcode::ColdCCall:
return ColdCCallCustom::hasNonArgEffects(*this);
case Opcode::WasmBoundsCheck:
return WasmBoundsCheckCustom::hasNonArgEffects(*this);
default:
return false;
}
}
CCallHelpers::Jump Inst::generate(CCallHelpers& jit, GenerationContext& context)
{
UNUSED_PARAM(jit);
UNUSED_PARAM(context);
CCallHelpers::Jump result;
switch (this->kind.opcode) {
case Opcode::Nop:
jit.nop();
OPGEN_RETURN(result);
break;
break;
case Opcode::Add32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
jit.add32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.add32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
jit.add32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.add16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Add64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.add64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.add64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.add64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.add64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.add64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.addDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AddFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.addFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.addFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Sub32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.sub32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
jit.sub32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.sub32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
jit.sub32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Sub64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.sub64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.sub64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.sub64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.sub64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.sub64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.sub64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
#if CPU(ARM64)
jit.sub64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SubDouble:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.subDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].asBaseIndex(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::SubFloat:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.subFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].asBaseIndex(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.subFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Neg32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.neg32(args[0].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.neg32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.neg32(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Neg64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.neg64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.neg64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.neg64(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::NegateDouble:
#if CPU(ARM64)
jit.negateDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::NegateFloat:
#if CPU(ARM64)
jit.negateFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Mul32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.mul32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mul32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.mul32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Mul64:
switch (this->args.size()) {
case 2:
#if CPU(X86_64) || CPU(ARM64)
jit.mul64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 3:
jit.mul64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MultiplyAdd32:
#if CPU(ARM64)
jit.multiplyAdd32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplyAdd64:
#if CPU(ARM64)
jit.multiplyAdd64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplySub32:
#if CPU(ARM64)
jit.multiplySub32(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplySub64:
#if CPU(ARM64)
jit.multiplySub64(args[0].gpr(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplyNeg32:
#if CPU(ARM64)
jit.multiplyNeg32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MultiplyNeg64:
#if CPU(ARM64)
jit.multiplyNeg64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Div32:
#if CPU(ARM64)
jit.div32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::UDiv32:
#if CPU(ARM64)
jit.uDiv32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Div64:
#if CPU(ARM64)
jit.div64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::UDiv64:
#if CPU(ARM64)
jit.uDiv64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MulDouble:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mulDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MulFloat:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.mulFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].fpr(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asAddress(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asBaseIndex(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.mulFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivDouble:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.divDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.divDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.divDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::DivFloat:
switch (this->args.size()) {
case 3:
#if CPU(ARM64)
jit.divFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.divFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.divFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::X86ConvertToDoubleWord32:
#if CPU(X86) || CPU(X86_64)
jit.x86ConvertToDoubleWord32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86ConvertToQuadWord64:
#if CPU(X86_64)
jit.x86ConvertToQuadWord64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86Div32:
#if CPU(X86) || CPU(X86_64)
jit.x86Div32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86UDiv32:
#if CPU(X86) || CPU(X86_64)
jit.x86UDiv32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86Div64:
#if CPU(X86_64)
jit.x86Div64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::X86UDiv64:
#if CPU(X86_64)
jit.x86UDiv64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Lea32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.lea32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.x86Lea32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Lea64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.lea64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.x86Lea64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::And32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
jit.and32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.and32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.and32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::And64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.and64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
jit.and64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.and64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.and64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.and64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.and64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.and64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.and64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.and64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.and64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AndDouble:
switch (this->args.size()) {
case 3:
jit.andDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.andDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AndFloat:
switch (this->args.size()) {
case 3:
jit.andFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.andFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::OrDouble:
switch (this->args.size()) {
case 3:
jit.orDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.orDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::OrFloat:
switch (this->args.size()) {
case 3:
jit.orFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.orFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::XorDouble:
switch (this->args.size()) {
case 3:
#if CPU(X86) || CPU(X86_64)
jit.xorDouble(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.xorDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::XorFloat:
switch (this->args.size()) {
case 3:
#if CPU(X86) || CPU(X86_64)
jit.xorFloat(args[0].fpr(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 2:
#if CPU(X86) || CPU(X86_64)
jit.xorFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Lshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.lshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.lshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.lshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.lshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Lshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.lshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.lshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.lshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.lshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.rshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.rshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Rshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.urshift32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.urshift32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.urshift32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.urshift32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Urshift64:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.urshift64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.urshift64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.urshift64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.urshift64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rotateRight32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rotateRight32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rotateRight32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rotateRight32(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateRight64:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rotateRight64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rotateRight64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(ARM64)
jit.rotateRight64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(ARM64)
jit.rotateRight64(args[0].gpr(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::RotateLeft32:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rotateLeft32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rotateLeft32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::RotateLeft64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.rotateLeft64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.rotateLeft64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Or32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
jit.or32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.or32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.or32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Or64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.or64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
jit.or64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.or64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.or64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.or64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.or64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.or64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.or64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.or64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.or64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor32:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::BitImm:
#if CPU(ARM64)
jit.xor32(args[0].asTrustedImm32(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asAddress(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.xor32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.xor32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Xor64:
switch (this->args.size()) {
case 3:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.xor64(args[0].gpr(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
jit.xor64(args[0].asTrustedImm64(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
default:
break;
}
break;
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.xor64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.xor64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.xor64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.xor64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.xor64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.xor64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.xor64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
jit.xor64(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not32:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
jit.not32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.not32(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Not64:
switch (this->args.size()) {
case 2:
#if CPU(ARM64)
jit.not64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 1:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.not64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.not64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.not64(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AbsDouble:
#if CPU(ARM64)
jit.absDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::AbsFloat:
#if CPU(ARM64)
jit.absFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::CeilDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.ceilDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::CeilFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.ceilFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.ceilFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::FloorDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.floorDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.floorDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::FloorFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.floorFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.floorFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SqrtDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sqrtDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SqrtFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.sqrtFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.sqrtFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertInt32ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertInt32ToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.convertInt64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.convertInt64ToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt32ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertInt32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertInt32ToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertInt64ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.convertInt64ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.convertInt64ToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.countLeadingZeros32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.countLeadingZeros32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::CountLeadingZeros64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.countLeadingZeros64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.countLeadingZeros64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertDoubleToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertDoubleToFloat(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertDoubleToFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ConvertFloatToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.convertFloatToDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.convertFloatToDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Move:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.move(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storePtr(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storePtr(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.signExtend32ToPtr(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.storePtr(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
#if USE(JSVALUE64)
case Arg::BigImm:
jit.move(args[0].asTrustedImm64(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
#endif // USE(JSVALUE64)
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadPtr(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadPtr(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case 3:
jit.move(args[0].asAddress(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Swap32:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.swap32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.swap32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Swap64:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.swap64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.swap64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Move32:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.zeroExtend32ToPtr(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.store32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.zeroExtend32ToPtr(args[0].asTrustedImm32(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case 3:
jit.move32(args[0].asAddress(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::StoreZero32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeZero32(args[0].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeZero32(args[0].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::StoreZero64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
jit.storeZero64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
jit.storeZero64(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SignExtend32ToPtr:
jit.signExtend32ToPtr(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::ZeroExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SignExtend8To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend8To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::ZeroExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.zeroExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::SignExtend16To32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.signExtend16To32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveFloat:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeFloat(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeFloat(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case 3:
jit.moveFloat(args[0].asAddress(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveDouble:
switch (this->args.size()) {
case 2:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Tmp:
jit.moveDouble(args[0].fpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.storeDouble(args[0].fpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.storeDouble(args[0].fpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case 3:
jit.moveDouble(args[0].asAddress(), args[1].asAddress(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveZeroToDouble:
jit.moveZeroToDouble(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Move64ToDouble:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.move64ToDouble(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.loadDouble(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
jit.loadDouble(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Move32ToFloat:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.move32ToFloat(args[0].gpr(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.loadFloat(args[0].asAddress(), args[1].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
jit.loadFloat(args[0].asBaseIndex(), args[1].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleTo64:
switch (this->args[0].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleTo64(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64) || CPU(ARM64)
jit.load64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64) || CPU(ARM64)
jit.load64(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveFloatTo32:
switch (this->args[0].kind()) {
case Arg::Tmp:
jit.moveFloatTo32(args[0].fpr(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Load8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load8(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq8:
#if CPU(ARMv7) || CPU(ARM64)
jit.loadAcq8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Store8:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel8:
#if CPU(ARMv7) || CPU(ARM64)
jit.storeRel8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Load8SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load8SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq8SignedExtendTo32:
#if CPU(ARMv7) || CPU(ARM64)
jit.loadAcq8SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Load16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load16(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq16:
#if CPU(ARMv7) || CPU(ARM64)
jit.loadAcq16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Load16SignedExtendTo32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.load16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Index:
jit.load16SignedExtendTo32(args[0].asBaseIndex(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::LoadAcq16SignedExtendTo32:
#if CPU(ARMv7) || CPU(ARM64)
jit.loadAcq16SignedExtendTo32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Store16:
switch (this->args[0].kind()) {
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Index:
jit.store16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
jit.store16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.store16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.store16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::StoreRel16:
#if CPU(ARMv7) || CPU(ARM64)
jit.storeRel16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadAcq32:
#if CPU(ARMv7) || CPU(ARM64)
jit.loadAcq32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreRel32:
#if CPU(ARMv7) || CPU(ARM64)
jit.storeRel32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadAcq64:
#if CPU(ARM64)
jit.loadAcq64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreRel64:
#if CPU(ARM64)
jit.storeRel64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Xchg8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xchg8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.xchg8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Xchg16:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xchg16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.xchg16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Xchg32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.xchg32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.xchg32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Xchg64:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.xchg64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.xchg64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS8:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS8(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS8(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS16:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS16(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS16(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS32:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS32(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicStrongCAS32(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicStrongCAS64:
switch (this->args.size()) {
case 5:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[2].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicStrongCAS64(args[0].gpr(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicStrongCAS64(args[0].gpr(), args[1].gpr(), args[2].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS8:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS8(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS16:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS16(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS32:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAtomicStrongCAS32(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchAtomicStrongCAS64:
switch (this->args[3].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branchAtomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branchAtomicStrongCAS64(args[0].asStatusCondition(), args[1].gpr(), args[2].gpr(), args[3].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicAdd8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAdd32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAdd64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicAdd64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicAdd64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicAdd64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicAdd64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicSub32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicSub64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicSub64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicSub64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicSub64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicSub64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicAnd32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicAnd64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicAnd64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicAnd64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicAnd64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicAnd64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicOr32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicOr64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicOr64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicOr64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicOr64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicOr64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor8:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor8(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor8(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor16:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor16(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor16(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor32:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor32(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor32(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXor32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicXor64:
switch (this->args[0].kind()) {
case Arg::Imm:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicXor64(args[0].asTrustedImm32(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicXor64(args[0].asTrustedImm32(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicXor64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicXor64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::AtomicNeg8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg8(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg8(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNeg16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg16(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg16(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNeg32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNeg32(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNeg64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicNeg64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicNeg64(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot8:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot8(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot8(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot16:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot16(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot16(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot32:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot32(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicNot32(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicNot64:
switch (this->args[0].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicNot64(args[0].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicNot64(args[0].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd16:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchgAdd32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchgAdd64:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicXchgAdd64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicXchgAdd64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg8(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg8(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg16:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg16(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg16(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg32(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.atomicXchg32(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::AtomicXchg64:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.atomicXchg64(args[0].gpr(), args[1].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86_64)
jit.atomicXchg64(args[0].gpr(), args[1].asBaseIndex());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::LoadLink8:
#if CPU(ARM64)
jit.loadLink8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLinkAcq8:
#if CPU(ARM64)
jit.loadLinkAcq8(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCond8:
#if CPU(ARM64)
jit.storeCond8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCondRel8:
#if CPU(ARM64)
jit.storeCondRel8(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLink16:
#if CPU(ARM64)
jit.loadLink16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLinkAcq16:
#if CPU(ARM64)
jit.loadLinkAcq16(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCond16:
#if CPU(ARM64)
jit.storeCond16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCondRel16:
#if CPU(ARM64)
jit.storeCondRel16(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLink32:
#if CPU(ARM64)
jit.loadLink32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLinkAcq32:
#if CPU(ARM64)
jit.loadLinkAcq32(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCond32:
#if CPU(ARM64)
jit.storeCond32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCondRel32:
#if CPU(ARM64)
jit.storeCondRel32(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLink64:
#if CPU(ARM64)
jit.loadLink64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::LoadLinkAcq64:
#if CPU(ARM64)
jit.loadLinkAcq64(args[0].asAddress(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCond64:
#if CPU(ARM64)
jit.storeCond64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::StoreCondRel64:
#if CPU(ARM64)
jit.storeCondRel64(args[0].gpr(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Depend32:
#if CPU(ARM64)
jit.depend32(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Depend64:
#if CPU(ARM64)
jit.depend64(args[0].gpr(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::Compare32:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.compare32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::Compare64:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.compare64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Test32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.test32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.test32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.test32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::Test64:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.test64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::CompareDouble:
jit.compareDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::CompareFloat:
jit.compareFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Branch8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branch8(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branch8(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Branch32:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branch32(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::Branch64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branch64(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTest8:
switch (this->args[1].kind()) {
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest8(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest8(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTest32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
result = jit.branchTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
result = jit.branchTest32(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchTest64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
#if USE(JSVALUE64)
case Arg::BitImm64:
#if CPU(ARM64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm64());
OPGEN_RETURN(result);
#endif
break;
break;
#endif // USE(JSVALUE64)
case Arg::BitImm:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::BitImm:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
result = jit.branchTest64(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchDouble:
result = jit.branchDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::BranchFloat:
result = jit.branchFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::BranchAdd32:
switch (this->args.size()) {
case 4:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchAdd64:
switch (this->args.size()) {
case 4:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 3:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
result = jit.branchAdd64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::BranchMul32:
switch (this->args.size()) {
case 3:
switch (this->args[1].kind()) {
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 4:
#if CPU(X86) || CPU(X86_64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 6:
#if CPU(ARM64)
result = jit.branchMul32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchMul64:
switch (this->args.size()) {
case 3:
#if CPU(X86_64)
result = jit.branchMul64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 6:
#if CPU(ARM64)
result = jit.branchMul64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchSub32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].gpr(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Imm:
switch (this->args[2].kind()) {
case Arg::Tmp:
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].asAddress());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
result = jit.branchSub32(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchSub64:
switch (this->args[1].kind()) {
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchSub64(args[0].asResultCondition(), args[1].asTrustedImm32(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchSub64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::BranchNeg32:
result = jit.branchNeg32(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::BranchNeg64:
#if CPU(X86_64) || CPU(ARM64)
result = jit.branchNeg64(args[0].asResultCondition(), args[1].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::MoveConditionally32:
switch (this->args.size()) {
case 5:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.moveConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionally64:
switch (this->args.size()) {
case 5:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest32:
switch (this->args.size()) {
case 5:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.moveConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyTest64:
switch (this->args.size()) {
case 5:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case 6:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
default:
break;
}
break;
case Opcode::MoveConditionallyDouble:
switch (this->args.size()) {
case 6:
jit.moveConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case 5:
jit.moveConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveConditionallyFloat:
switch (this->args.size()) {
case 6:
jit.moveConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr(), args[5].gpr());
OPGEN_RETURN(result);
break;
break;
case 5:
jit.moveConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].gpr(), args[4].gpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Imm:
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionally32(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionally64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].gpr(), args[2].asAddress(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
jit.moveDoubleConditionally64(args[0].asRelationalCondition(), args[1].asBaseIndex(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest32:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Arg::BitImm:
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Index:
#if CPU(X86) || CPU(X86_64)
jit.moveDoubleConditionallyTest32(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyTest64:
switch (this->args[1].kind()) {
case Arg::Tmp:
switch (this->args[2].kind()) {
case Arg::Tmp:
#if CPU(X86_64) || CPU(ARM64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Imm:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].gpr(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Addr:
case Arg::Stack:
case Arg::CallArg:
switch (this->args[2].kind()) {
case Arg::Imm:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Arg::Tmp:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asAddress(), args[2].gpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Arg::Index:
#if CPU(X86_64)
jit.moveDoubleConditionallyTest64(args[0].asResultCondition(), args[1].asBaseIndex(), args[2].asTrustedImm32(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
#endif
break;
break;
default:
break;
}
break;
case Opcode::MoveDoubleConditionallyDouble:
jit.moveDoubleConditionallyDouble(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::MoveDoubleConditionallyFloat:
jit.moveDoubleConditionallyFloat(args[0].asDoubleCondition(), args[1].fpr(), args[2].fpr(), args[3].fpr(), args[4].fpr(), args[5].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::MemoryFence:
jit.memoryFence();
OPGEN_RETURN(result);
break;
break;
case Opcode::StoreFence:
jit.storeFence();
OPGEN_RETURN(result);
break;
break;
case Opcode::LoadFence:
jit.loadFence();
OPGEN_RETURN(result);
break;
break;
case Opcode::Jump:
result = jit.jump();
OPGEN_RETURN(result);
break;
break;
case Opcode::RetVoid:
jit.retVoid();
OPGEN_RETURN(result);
break;
break;
case Opcode::Ret32:
jit.ret32(args[0].gpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Ret64:
#if CPU(X86_64) || CPU(ARM64)
jit.ret64(args[0].gpr());
OPGEN_RETURN(result);
#endif
break;
break;
case Opcode::RetFloat:
jit.retFloat(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::RetDouble:
jit.retDouble(args[0].fpr());
OPGEN_RETURN(result);
break;
break;
case Opcode::Oops:
jit.oops();
OPGEN_RETURN(result);
break;
break;
case Opcode::EntrySwitch:
OPGEN_RETURN(EntrySwitchCustom::generate(*this, jit, context));
break;
case Opcode::Shuffle:
OPGEN_RETURN(ShuffleCustom::generate(*this, jit, context));
break;
case Opcode::Patch:
OPGEN_RETURN(PatchCustom::generate(*this, jit, context));
break;
case Opcode::CCall:
OPGEN_RETURN(CCallCustom::generate(*this, jit, context));
break;
case Opcode::ColdCCall:
OPGEN_RETURN(ColdCCallCustom::generate(*this, jit, context));
break;
case Opcode::WasmBoundsCheck:
OPGEN_RETURN(WasmBoundsCheckCustom::generate(*this, jit, context));
break;
default:
break;
}
RELEASE_ASSERT_NOT_REACHED();
return result;
}
} } } // namespace JSC::B3::Air
#endif // AirOpcodeGenerated_h
